from .dbo import DBO

class MaxRTT(DBO):
	"""
	MaxRTT calculates the bounds on end-to-end latency to achieve Response Time Fairness.
	To minimize delay, there is no buffering at the RBs. MaxRTT assumes knowledge of trigger
	points of the trades.
	"""
	def __init__(self):
		super().__init__()

	def get_title(self):
		return "MaxRTT"

	def get_d_time(self, g_time, r_time):
		return r_time

	def get_ordering(self, d_time, submission_time, time_range):
		"""
		Generate a total ordering of trades in which they can be executed.

		For MaxRTT, the trade is ordered based on the response time, which can be calculated using the
		delivery time (`d_time`) and the submission time (`submission_time`). The ordering here for a
		trade in response to the data point `x` with response time `rt` is defined as (x*time_range + rt).
		This enforces the lexicographic sorting for the tuple (x, rt).

		Overriding the method from the super class (Algorithm).

		Args:
			d_time (list(float)): Real times when RB sends data points to the MP.
			submission_time (list(float)): Real times when trade is submitted to the RB from the MP.
			time_range (float): The time horizon being simulated.

		Returns:
			list(float): A total ordering of trades.
		"""
		answer = []
		for x in range(len(submission_time)):
			rt = submission_time[x]-d_time[x]
			answer.append(x * time_range + rt)
		return answer

	def get_execution_time(self, ordering, d_time_arr, time_range, ack_time_arr):
		"""
		Get the execution time of trades from a single MP.

		For MaxRTT, all RBs continuously send heartbeats to the CES at each time step. When
		a trade is is received at OB in response to data point `x` with response time `rt`,
		OB waits for heartbeats from all RBs which are generated after `rt` time has passed
		since delivery of data point `x` to respective MPs. As soon as all heartbeats are received,
		this trade is also exected.

		Overriding the method from the super class (Algorithm).

		Args:
			ordering (list(float)): A total ordering of trades.
			d_time_arr (list(list(float))): Real times when RB sends data points to all MPs.
			time_range (float): The time horizon being simulated.
			ack_time_arr (list(list(float))): Real times when acks are received from all MPs.

		Returns:
			list(float): Real times of execution of trades from a single MP at the CES.
		"""
		answer = []
		for i in range(len(ordering)):
			x = int(ordering[i]/time_range)
			rt = ordering[i]-i*time_range
			max_s  = -1
			for j in range(len(d_time_arr)):
				d_time_ind = x
				while d_time_arr[j][d_time_ind] < d_time_arr[j][x]+rt and d_time_ind < len(d_time_arr[j]) - 1:
					d_time_ind += 1
				max_s = max(max_s, ack_time_arr[j][d_time_ind])
			answer.append(max_s)
		return answer

	def run_simulation(self):
		## The environment should be set before calling this function.
		for i in range(self.number_participants):
			# Calculate the times when the RB`i` receives the data points from the CES using the one way delays.
			self.r_time_arr.append(self.get_r_time(self.g_time, self.fw_owd_arr[i]))
			# Calculate when the data point is delivered by the RB`i` to the MP`i`.
			self.d_time_arr.append(self.get_d_time(self.g_time, self.r_time_arr[i]))
			# Calculate when trades are generated by MP`i` in response to the data points received and sent to the RB`i`.
			self.submission_time_arr.append(self.get_submission_time(self.d_time_arr[i], self.response_times[i]))
			# Calculate when trades are received at the OB from RB`i`.
			self.receive_at_ob_arr.append(self.get_receive_at_ob(self.submission_time_arr[i], self.rv_owd_arr[i]))
			# Calculate the order of trades from RB`i` at the CES.
			self.ordering_arr.append(self.get_ordering(self.d_time_arr[i], self.submission_time_arr[i], self.time_range))
			# After each data point is delivered to the MP`i`, RB`i` sends an ACK to the CES.
			# Calculate the times when the ACK reaches the CES.
			self.ack_time_arr.append(self.get_receive_at_ob(self.d_time_arr[i], self.rv_owd_arr[i]))

		for i in range(self.number_participants):
			# Calculate the execution time of trades from RB`i` at the CES
			self.execution_time_arr.append(self.get_execution_time(self.ordering_arr[i], self.d_time_arr, self.time_range, self.ack_time_arr))
			# Calculate the latency for each trade (ignore last 25/g_step points to ensure it is within `time_range`)
			self.latency_arr.append(self.get_e2e_latency(
				self.g_time, self.execution_time_arr[i], self.response_times[i])[:(-int((25.0/self.g_step) + 1))])
