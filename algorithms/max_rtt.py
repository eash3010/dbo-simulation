from .dbo import DBO

class MaxRTT(DBO):
	"""
	MaxRTT calculates the bounds on end-to-end latency to achieve Response Time Fairness.
	To minimize delay, there is no buffering at the RBs. MaxRTT assumes knowledge or trigger
	points and that heartbeats at each time step are being sent from all RBs to the CES.
	"""
	def __init__(self):
		super().__init__()

	def get_title(self):
		return "MaxRTT"

	def get_d_time(self, g_time, r_time):
		return r_time

	def get_ordering(self, d_time, submission_time, time_range):
		"""
		Generate a total ordering of trades in which they can be executed.

		For MaxRTT, the trade is ordered based on the response time, which can be calculated using the
		delivery time (`d_time`) and the submission time (`submission_time`). The ordering here for a
		trade in response to the data point `x` is defined as (x*time_range + t). This enforces the
		lexicographic sorting for the tuple (x,t).

		Overriding the method from the super class (Algorithm).

		Args:
			d_time (list(float)): Real times when RB sends data points to the MP.
			submission_time (list(float)): Real times when trade is submitted to the RB from the MP.
			time_range (float): The time horizon being simulated.

		Returns:
			list(float): A total ordering of trades.
		"""
		answer = []
		for x in range(len(submission_time)):
			answer.append(x * time_range + submission_time[x]-d_time[x])
		return answer

	def get_execution_time(self, ordering, d_time_arr, time_range, rv_owd):
		"""
		Get the execution time of trades from a single MP.

		For MaxRTT, all RBs continuously send heartbeats to the CES at each time step. When
		a trade is is received at OB in response to data point `x` with response time `rt`,
		OB waits for heartbeats from all RBs which are generated after `rt` time has passed
		since delivery of data point `x` to respective MPs. As soon as all heartbeats are received,
		this trade is also exected.

		Overriding the method from the super class (Algorithm).

		Args:
			ordering (list(float)): A total ordering of trades.
			ack_time_arr (list(float)): Real times when acks are received from all MPs.
			time_range (float): The time horizon being simulated.

		Returns:
			list(float): Real times of execution of trades from a single MP at the CES.
		"""
		answer = []
		for i in range(len(ordering)):
			x = int(ordering[i]/time_range)
			rt = ordering[i]-i*time_range
			max_s  = -1
			for j in range(len(d_time_arr)):
				max_s = max(max_s, d_time_arr[j][x]+rt+rv_owd[int(d_time_arr[j][x]+rt)])
			answer.append(max_s)
		return answer

	def run_simulation(self):
		## The environment should be set before calling this function.
		for i in range(self.number_participants):
			# Calculate the times when the RB`i` receives the data points from the CES using the one way delays.
			self.r_time_arr.append(self.get_r_time(self.g_time, self.fw_owd_arr[i]))
			# Calculate when the data point is delivered by the RB`i` to the MP`i`.
			self.d_time_arr.append(self.get_d_time(self.g_time, self.r_time_arr[i]))
			# Calculate when trades are generated by MP`i` in response to the data points received and sent to the RB`i`.
			self.submission_time_arr.append(self.get_submission_time(self.d_time_arr[i], self.response_times[i]))
			# Calculate when trades are received at the OB from RB`i`.
			self.receive_at_ob_arr.append(self.get_receive_at_ob(self.submission_time_arr[i], self.rv_owd_arr[i]))
			# Calculate the order of trades from RB`i` at the CES.
			self.ordering_arr.append(self.get_ordering(self.d_time_arr[i], self.submission_time_arr[i], self.time_range))
			# After each data point is delivered to the MP`i`, RB`i` sends an ACK to the CES.
			# Calculate the times when the ACK reaches the CES.
			self.ack_time_arr.append(self.get_receive_at_ob(self.d_time_arr[i], self.rv_owd_arr[i]))

		for i in range(self.number_participants):
			# Calculate the execution time of trades from RB`i` at the CES
			self.execution_time_arr.append(self.get_execution_time(self.ordering_arr[i], self.d_time_arr, self.time_range, self.rv_owd_arr[i]))
			# Calculate the latency for each trade (ignore last 25/g_step points to ensure it is within `time_range`)
			self.latency_arr.append(self.get_e2e_latency(
				self.g_time, self.execution_time_arr[i], self.response_times[i])[:(-int((25.0/self.g_step) + 1))])
